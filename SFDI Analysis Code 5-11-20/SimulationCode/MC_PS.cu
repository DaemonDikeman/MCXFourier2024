/** GPU accelerated Monte-Carlo solver for multi-layer media simulations **/
/** This program was developed based on the MCML method by Wang and Jacques (1995) 
"MCML - Monte Carlo modeling of light transport in multi-layered tissues"

This program is written in CUDA-C, which is a C/C++ based library freely available from NVIDIA to run on NVIDIA GPUs

These simulations assume that the phantom being modeled is perfectly flat and may consist of flat, uniform layers.
All photons are launched as a pencil beam described by a single set of coordinates (x,y,z){mm}, and a single set of directional
cosines described by (ux,uy,uz). Medium properties are described on a layer-by-layer basis and consist of
(mua, mus, g, n, layerZ){mm^-1, mm^-1, unitless, unitless, mm}, which represent the absporption coefficent, scattering coefficient,
scattering anisotropy, refractive index, and boundary locations of the layers. By default, the program returns the final x,y,z locations,
final weight, and exit status of each photon, as well as the partial pathlenth, cumulative momentum transfer, and number of scattering events for every photon on a 
layer-by-layer basis.

If more outputs are desired, add them into the code at both the main kernel and declair the output in the kernel argument
**/


/* Include statements tell the compiler to include the standard math library 
and some CUDA libraries to use pre-developed functions such as random number generators. 
*/

#include<math.h>
#include<cuda_runtime.h>
#include<curand_kernel.h>

/* Define the max number of layers allowed (this can be increased if needed). */
#define NLAYERS 10 

/* Data structure definitions allow many instances of an "object" to be in memory and be easily
accessible by name. The photon structure lists all of the attributes of a photon that can be accessed
and modified as the simulation progresses. The medium structure holds all of the information about the
medium in which the photons are interacting with. */

struct photon
{
    float x,y,z; // (x,y,z) position
    float ux,uy,uz; //(ux,uy,uz) directions
    float mut; // coefficient of interaction
    float s; // unitless step size
    float db; // distance to boundary
    float step; // step size {mm}
    float costheta; // cosine(scattering angle)
    float w; // photon weight (relative energy)
    float maxZ; //Maximum penetration depth of photon
    int layerID; // the layer the photon currently resides
    int alive; // is the photon alive? true or false
    int exit; // did the photon exit the medium? true or false
    float ppath[NLAYERS-1]; // cumulative partial pathlength by layer (vector)
    float mom[NLAYERS-1]; // cumulative momentum transfer by layer (vector)
    int nscat[NLAYERS-1]; // number of scattering events by layer (vector)
};

struct medium
{
    float nLayers; //Number of layers
    float mua[NLAYERS]; // absorbtion coefficient by layer (vector)
    float mus[NLAYERS]; //scattering coefficient by layer (vector)
    float g[NLAYERS]; // scattering anisotropy by layer (vector)
    float n[NLAYERS]; // refractive index by layer (vector)
    float layerZ[NLAYERS]; // layer locations (vector)
};

/* This section declairs the functions used by the GPU kernel (main function) and the types of inputs
and outputs used and generated by them. Any variable preceeded by a '*' indicates that it is a memory
address that points to either a vector or a data structure (struct) described above. Any varible that
is preeceded by 'const datatype' indicates that the variable is a constant and is 'read only' */

/* INITPHOTONPARAMS populates the photon data structure with initial values. It takes a pointer to the
photon data structure, a list of desired photon parameters, and the number of layers of the medium */ 
__device__ void initPhotonParams(struct photon *p, const float *photonParams, const int nLayers);

/* INITMEDIUMPARAMS populates the medium data structure with values. It takes a pointer to the structure,
a list of medium properties, and the number of layers of the medium */
__device__ void initMediumParams(struct medium *m, const float *mediumParams, const int nLayers);

/* DRAWS accepts a random number between 0 and 1 and uses it to update the unitless step size field 's' of photon p */
__device__ void drawS(struct photon *p, float random);

/* GETDISTANCETOBOUNDARY calculates how far the photon is from a boundary and updates the 'db' field of photon p.*/
__device__ void getDistanceToBoundary(struct photon *p, struct medium *m);

/* UPDATEPOSITION updates the (x,y,z) fields of photon p based on the step-size 'step' and direction cosines (ux,uy,uz) */
__device__ void updatePosition(struct photon *p);

/* UPDATEDIRECTIONFRESNEL updates the (ux,uy,uz) fields of photon p according to fresnel reflections\transmission coefficients
for boundary interactions */
__device__ void updateDirectionFresnel(struct photon *p, struct medium *m, float random);

/* UPDATEWEIGHT updates the weight field 'w' of photon p based on absorption properties of medium m */
__device__ void updateWeight(struct photon *p, struct medium *m);

/* ROULETTE performs Russian roulette on a photon to update the 'alive' field of photon p */
__device__ void roulette(struct photon *p, float random);

/* UPDATEDIRECTION updates the (ux,uy,uz) fields of photon p according to the Henyey-Greenstein phase function at
non-boundary interaction sites */
__device__ void updateDirection(struct photon *p, struct medium *m, float random1, float random2);

/* HG returns a cos(scattering angle) of photon p at a scattering site */
__device__ float HG(struct photon *p, struct medium *m, float random);

/* Below is the main kernel for the GPU
It accepts 4 simulation parameters, 2 photon/medium parameter vectors and populates the
output vectors to return to the host system. The entire simulation is done on the GPU.

INPUTS:
nPhot (integer): number of photons to simulate
nLayers (integer): number of layers in the medium
randSeed (integer): seed for the random number generator
scatMax (integer): maximum number of loop iterations for photon propagation
photonParams (float vector): initial photon position and direction [x,y,z,ux,uy,uz]
mediumParams (float vector): medium properties by layer [mua, mus ,g, n, layerZ, mua... , layerZ, ...]

OUTPUTS:
ppath (float vector): partial pathlength of each photon by layer of length (nPhot * nLayers)
mom (float vector): cumulative momentum transfer (costheta) of each photon by layer of length (nPhot * nLayers)
nscat (integer vector): number of scattering events of each photon by layer of length (nPhot * nLayers)
finalx (float vector): final x position of each photon
finaly (float vector): final y position of each photon
finalz (float vector): final z position of each photon

*/
__global__ void MC(const int nPhot, const int nLayers, const int randSeed, const int scatMax,
    const float *photonParams, const float *mediumParams,
    float *ppath, float *mom, int *nscat, float *finalx, float *finaly, 
    float *finalz, float *finalux, float *finaluy, float *finaluz, float *finalw, float *finalMaxZ, int *exit)
{
    /* Get the thread ID on the GPU */
    int idx = blockIdx.x*blockDim.x + threadIdx.x;
    /* The below code is run in parallel by many threads. Each photon gets in own thread */
    if (idx < nPhot) // Ensure that the thread ID is less than the total number of photons
    {
        curandState state; // random number generator state variable
        // Initialize the random number generator based on the unique thread ID
        curand_init(idx + randSeed, 0, 0, &state);
        // Allocate local memory for photon properties
        struct photon p;
        // Allocate local memory for medium properties
        struct medium m;
        //Populate photon properties
        initPhotonParams(&p, photonParams, nLayers);
        //Populate medium properties
        initMediumParams(&m, mediumParams, nLayers);
        //Decliar 2 random number variables
        float r1,r2;
        //Initialize Interaction Coefficient
        p.mut = m.mua[p.layerID] + m.mus[p.layerID];
        int iter = 0; // iter is a loop counter variable
        //Below is the main do-while loop for photon propagation
        do //Photon Random Walk
        {
            //Draw unitless step if s is 0
            if (p.s == 0)
            {
                r1 = curand_uniform(&state); //Generate a random number
                drawS(&p, r1);
            }
            getDistanceToBoundary(&p, &m);
            // If the photon will interact with a boundary:
            if (p.s > p.db * p.mut)
            {
                // Boundary Code
                p.step = p.db; // Set step size to distance to boundary
                updatePosition(&p); //Go to boundary
                p.ppath[p.layerID-1] += p.step; // Update ppath
                p.s = p.s - (p.db*p.mut); // Update unitless step to continue traveling
                r1 = curand_uniform(&state); // Draw a new random number
                updateDirectionFresnel(&p, &m, r1); // Transmit or reflect
                p.mom[p.layerID-1] += (1 - p.costheta); // Update momentum transfer
            }
            else
            {
                //Infinite Medium Code
                p.step = p.s/p.mut; // Update step size
                updatePosition(&p);
                p.ppath[p.layerID-1] += p.step; // Update ppath
                p.s = 0; // Reset unitless step size
                updateWeight(&p, &m);
                r1 = curand_uniform(&state); // Draw a new random number
                r2 = curand_uniform(&state); // Draw another new random number
                updateDirection(&p, &m, r1, r2);
                p.mom[p.layerID-1] += (1 - p.costheta); // Update momentum transfer
                p.nscat[p.layerID-1] += 1; // Update nscat
            }
            // If the photon is still alive
            if (p.alive == 1)
            {
                // If its weight is low
                if (p.w < 0.0001)
                {  
                    // Photon Termination Code
                    r1 = curand_uniform(&state); //Draw a new random number
                    roulette(&p, r1); // Perform random roulette
                }
            }
            iter++; // Update loop counter
        // Repeat the process if the photon is still alive and the loop counter isn't too high
        } while ((p.alive == 1) && (iter < scatMax));
        // Export results from the photon
        finalx[idx] = p.x;
        finaly[idx] = p.y;
        finalz[idx] = p.z;
        finalux[idx] = p.ux;
        finaluy[idx] = p.uy;
        finaluz[idx] = p.uz;

        finalw[idx] = p.w;
        finalMaxZ[idx] = p.maxZ;
        exit[idx] = p.exit;
        for(int i=0;i<(nLayers-1);i++)
        {
            ppath[idx*(nLayers-1) + i] = p.ppath[i];
            mom[idx*(nLayers-1) + i] = p.mom[i];
            nscat[idx*(nLayers-1) + i] = p.nscat[i];
        }
    }
}

/* Below is the code for  */
__device__ void initPhotonParams(struct photon *p, const float *inputParams1, const int nLayers)
{
    p->x = inputParams1[0];
    p->y = inputParams1[1];
    p->z = inputParams1[2];
    p->ux = inputParams1[3];
    p->uy = inputParams1[4];
    p->uz = inputParams1[5];
    p->mut = 0;
    p->s = 0;
    p->db = 0;
    p->step = 0;
    p->costheta = 0;
    p->layerID = 1;
    p->w = 1;
    p->maxZ = 0;
    p->alive = 1;
    p->exit = 0;
    for(int i=0;i<nLayers;i++)
    {
        p->ppath[i] = 0;
        p->mom[i] = 0;
        p->nscat[i] = 0;
    }
}

__device__ void initMediumParams(struct medium *m, const float *mediumParams, const int nLayers)
{
    for(int i=0;i<nLayers;i++)
    {
        m->mua[i] = mediumParams[5*i];
        m->mus[i] = mediumParams[5*i + 1];
        m->g[i] = mediumParams[5*i + 2];
        m->n[i] = mediumParams[5*i + 3];
        m->layerZ[i] = mediumParams[5*i + 4];
    }
    m->nLayers = nLayers;
}

__device__ void drawS(struct photon *p, float random)
{
    p->s = -logf(random);
}

__device__ void getDistanceToBoundary(struct photon *p, struct medium *m)
{
    // Get upper and lower boundaries
    float z0, z1;
    if (p->layerID != 0)
    {
        z0 = m->layerZ[p->layerID - 1];
        z1 = m->layerZ[p->layerID];

        // Get boundary Distance depending on photon direction
        if (p->uz < 0) //Photon Traveling Up (-z)
        {
            p->db = (z0 - p->z)/p->uz;
        }
        else if (p->uz > 0) //Photon Traveling Down (+z)
        {
            p->db = (z1 - p->z)/p->uz;
        }
        else
        { // Photon not traveling up or down
            p->db = 9999999999;
        }
    }
}

__device__ void updatePosition(struct photon *p)
{
    p->x += p->step * p->ux;
    p->y += p->step * p->uy;
    p->z += p->step * p->uz;
    if(p->z > p->maxZ)
    {
        p->maxZ = p->z;
    }
}

__device__ void updateDirectionFresnel(struct photon *p, struct medium *m, float random)
{
    //Get refractive indices
    float ni, nt;
    ni = m->n[p->layerID];
    if (p->uz > 0) //If photon is traveling down, its going into the next n
    {
        nt = m->n[p->layerID + 1];
    }
    else //If traveling back up, it's going into previous n
    {
        nt = m->n[p->layerID - 1];
    }
    
    //Calculate Reflectance Value
    float alphai, alphat, alphac, R;
    alphac = asinf(nt/ni);
    alphai = acosf(fabs(p->uz));
    if (alphai > alphac)
    {
        R = 1;
    }
    else
    {
        alphat = asinf(ni*sinf(alphai)/nt);
        R = 0.5*(((powf(sinf(alphai-alphat),2))/(powf(sinf(alphai+alphat),2)))+((powf(tanf(alphai-alphat),2))/(powf(tanf(alphai+alphat),2))));
    }
    
    //Decide if transmitted or reflected
    if (random <= R)
    {
        //Reflected
        p->costheta = (p->ux * p->ux) + (p->uy * p->uy) + (p->uz * -p->uz);
        p->uz = -p->uz;
    }
    else
    {
        //Transmitted
        if (p->uz > 0)
        {
            //Update Direction
            p->costheta = (p->ux * p->ux*(ni/nt)) + (p->uy * p->uy*(ni/nt)) + (p->uz * cosf(alphat));
            p->uz = cosf(alphat);
            p->ux = p->ux * (ni/nt);
            p->uy = p->uy * (ni/nt);
            //Update Layer Flag
            p->layerID = p->layerID + 1;
            if (p->layerID > m->nLayers-1)
            {
                p->alive = 0;
                p->exit = 1;
                p->z = m->layerZ[p->layerID-1];
            }
            p->mut = m->mua[p->layerID] + m->mus[p->layerID];
        }
        else
        {
            //Update Direction
            p->costheta = (p->ux * p->ux*(ni/nt)) + (p->uy * p->uy*(ni/nt)) + (p->uz * -cosf(alphat));
            p->ux = p->ux * (ni/nt);
            p->uy = p->uy * (ni/nt);
            p->uz = -cosf(alphat);
            //Update Layer Flag
            p->layerID = p->layerID - 1;
            if (p->layerID <= 0)
            {
                p->alive = 0;
                p->exit = 1;
                p->z = m->layerZ[p->layerID];
            }
            p->mut = m->mua[p->layerID] + m->mus[p->layerID];
        }
    }
}

__device__ void updateWeight(struct photon *p, struct medium *m)
{
    p->w = p->w - (m->mua[p->layerID]/p->mut)*p->w;
}

__device__ void roulette(struct photon *p, float random)
{
    if (random > 0.1 )
    {
        p->w = 0;
        p->alive = 0;
    }
}

__device__ float HG(struct photon *p, struct medium *m, float random)
{
    float g, costheta;
    g = m->g[p->layerID];
    if (g != 0)
    {
        costheta = (1/(2*g))*(1 + (g*g) - powf(((1-(g*g))/(1-g+(2*g*random))),2));
    }
    else
    {
        costheta = 2*random - 1;
    }
    return costheta;
}

__device__ void updateDirection(struct photon *p, struct medium *m, float random1, float random2)
{
    float uxtemp, uytemp, uztemp;
    float phi, costheta, cosphi, sintheta, sinphi, denom;

    costheta = HG(p, m, random1);
    phi = 2*3.14159265359*random2;
    uxtemp = p->ux;
    uytemp = p->uy;
    uztemp = p->uz;

    denom = sqrtf(1 - powf(uztemp,2));
    sintheta = sqrtf(1 - powf(costheta,2));
    cosphi = cosf(phi);
    sinphi = sinf(phi);
    if (fabs(uztemp) > 0.99999)
    {   
        p->ux = sintheta*cosphi;
        p->uy = sintheta*sinphi;
        if (uztemp > 0)
        {
            p->uz = costheta;
        }
        else
        {
            p->uz = -costheta;
        }
    }
    else
    {
        p->ux = (sintheta*(uxtemp*uztemp*cosphi - uytemp*sinphi))/(denom) + uxtemp*costheta;
        p->uy = (sintheta*(uytemp*uztemp*cosphi + uxtemp*sinphi))/(denom) + uytemp*costheta;
        p->uz = -sintheta*cosphi*denom + uztemp*costheta;
    }
    p->costheta = costheta;
}